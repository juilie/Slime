"use strict";function e(e){var n=Object.create(null);return e&&Object.keys(e).forEach((function(t){if("default"!==t){var o=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(n,t,o.get?o:{enumerable:!0,get:function(){return e[t]}})}})),n.default=e,Object.freeze(n)}var n=e(require("three"));class t{constructor(e,t){this.simulationMaterial=e,this.renderMaterial=t,this.state={baseColor:new n.Vector3(.1,.01,.8),targetBaseColor:new n.Vector3(.1,.01,.8),secondaryColor:new n.Vector4(0,0,0,0),targetSecondaryColor:new n.Vector4(0,0,0,0),neighborThreshold:.99,targetNeighborThreshold:.99,noiseFactor:0,targetNoiseFactor:0,roughness:.2,targetRoughness:.2,metalness:0,targetMetalness:0,speed:.15,targetSpeed:.15,isTransitioning:!1,duration:100,startTime:0}}startTransition(e){const n=performance.now();this.state.baseColor.set(this.renderMaterial.uniforms.uBaseColor.value.x,this.renderMaterial.uniforms.uBaseColor.value.y,this.renderMaterial.uniforms.uBaseColor.value.z),this.state.secondaryColor.set(this.renderMaterial.uniforms.uSecondaryColor.value.x,this.renderMaterial.uniforms.uSecondaryColor.value.y,this.renderMaterial.uniforms.uSecondaryColor.value.z,this.renderMaterial.uniforms.uSecondaryColor.value.w),this.state.neighborThreshold=this.simulationMaterial.uniforms.uNeighborThreshold.value,this.state.noiseFactor=this.simulationMaterial.uniforms.uNoiseFactor.value,this.state.roughness=this.renderMaterial.uniforms.uRoughness.value,this.state.metalness=this.renderMaterial.uniforms.uMetalness.value,this.state.speed=this.simulationMaterial.uniforms.uSpeed.value,e.baseColor?this.state.targetBaseColor.set(e.baseColor[0],e.baseColor[1],e.baseColor[2]):this.state.targetBaseColor.copy(this.state.baseColor),e.secondaryColor?this.state.targetSecondaryColor.set(e.secondaryColor[0],e.secondaryColor[1],e.secondaryColor[2],e.secondaryColor[3]):this.state.targetSecondaryColor.copy(this.state.secondaryColor),this.state.targetNeighborThreshold=void 0!==e.neighborThreshold?e.neighborThreshold:this.state.neighborThreshold,this.state.targetNoiseFactor=void 0!==e.noiseFactor?e.noiseFactor:this.state.noiseFactor,this.state.targetRoughness=void 0!==e.roughness?e.roughness:this.state.roughness,this.state.targetMetalness=void 0!==e.metalness?e.metalness:this.state.metalness,this.state.targetSpeed=void 0!==e.speed?e.speed:this.state.speed,this.state.isTransitioning=!0,this.state.startTime=n,this.state.duration=e.duration||1e3}update(){if(!this.state.isTransitioning)return;let e=(performance.now()-this.state.startTime)/this.state.duration;e>=1&&(e=1,this.state.isTransitioning=!1);const t=this.easeInOutCubic(e);this.renderMaterial.uniforms.uBaseColor.value.lerpVectors(this.state.baseColor,this.state.targetBaseColor,t),this.renderMaterial.uniforms.uSecondaryColor.value.lerpVectors(this.state.secondaryColor,this.state.targetSecondaryColor,t),this.simulationMaterial.uniforms.uNeighborThreshold.value=n.MathUtils.lerp(this.state.neighborThreshold,this.state.targetNeighborThreshold,t),this.simulationMaterial.uniforms.uNoiseFactor.value=n.MathUtils.lerp(this.state.noiseFactor,this.state.targetNoiseFactor,t),this.renderMaterial.uniforms.uRoughness.value=n.MathUtils.lerp(this.state.roughness,this.state.targetRoughness,t),this.renderMaterial.uniforms.uMetalness.value=n.MathUtils.lerp(this.state.metalness,this.state.targetMetalness,t),this.simulationMaterial.uniforms.uSpeed.value=n.MathUtils.lerp(this.state.speed,this.state.targetSpeed,t)}easeInOutCubic(e){return e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2}}const o={vert:"varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }",original:{sim:' precision highp float;\n        varying vec2 vUv;\n        uniform sampler2D uPreviousState;\n        uniform vec2 uResolution;\n        uniform vec2 uMouse;\n        uniform bool uIsMouseDown;\n        uniform float uTime;\n        uniform float uNoiseFactor;\n        uniform float uNeighborThreshold;\n        uniform float uSpeed;\n\n        // Continuous neighborhood counting\n        vec4 getNeighborhood(vec2 uv) {\n            vec2 texel = 1.0 / uResolution;\n            float alive = 0.0;\n            float total = 0.0;\n            \n            // Sample in a radius around the current position\n            float radius = 3.0;\n            float count = 0.0;\n            \n            for(float y = -radius; y <= radius; y++) {\n                for(float x = -radius; x <= radius; x++) {\n                    vec2 offset = vec2(x, y) * texel;\n                    float dist = length(offset * uResolution / radius);\n                    \n                    // Only count cells within a circle\n                    if(dist <= radius) {\n                        // Gaussian weight based on distance\n                        float weight = exp(-dist * dist / 4.0);\n                        \n                        vec4 state = texture2D(uPreviousState, uv + offset);\n                        alive += state.r * weight;\n                        total += weight;\n                        count += 1.0;\n                    }\n                }\n            }\n            \n            // Normalize the count to 0-1 range\n            alive = alive / total;\n            \n            // Calculate how close we are to having "3 neighbors"\n            // Map the continuous value to peak at 3/8 (equivalent to 3 neighbors in discrete version)\n            float neighborFactor = 1.0 - abs(alive - 0.375) * 4.0;\n            \n            return vec4(alive, neighborFactor, count, total);\n        }\n\n        float hash(vec2 p) {\n            return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n        }\n\n        void main() {\n            vec4 prevState = texture2D(uPreviousState, vUv);\n            vec4 neighborhood = getNeighborhood(vUv);\n            \n            float currentMass = prevState.r;\n            float currentVelocity = prevState.g;\n            float currentHeight = prevState.b;\n            \n            // Continuous version of Conway\'s rules\n            float birthRate = 0.91;  // How quickly cells come alive\n            float deathRate = 0.91;  // How quickly cells die\n            float sustainRate = 0.9; // How well cells maintain their state\n            \n            // Calculate state change based on neighborhood\n            float neighborFactor = neighborhood.y;\n            float targetMass = 0.0;\n            \n            // Birth rule (continuous version of "exactly 3 neighbors")\n            if(neighborFactor > uNeighborThreshold) {\n                targetMass = 2.0;\n            }\n            // Death rule (continuous version of underpopulation/overpopulation)\n            else if(neighborFactor < 0.6) {\n                targetMass = 0.0;\n            }\n            // Sustain current state with slight decay\n            else {\n                targetMass = currentMass * sustainRate;\n            }\n            \n            // Add some noise and movement\n            float noise = hash(vUv + vec2(uTime * 0.01));\n            float noiseFactor = uNoiseFactor;\n            \n            // Calculate new state\n            float newMass = mix(currentMass, targetMass, uSpeed) + (noise - 0.5) * noiseFactor;\n            float newVelocity = currentVelocity * 0.95;\n            float newHeight = currentHeight * 0.98 + newMass * 0.1;\n            \n            // Mouse interaction\n            vec2 mouseDist = vUv - uMouse;\n            if( uIsMouseDown && length(mouseDist) < 0.03) {\n                newMass = 0.50;\n                newHeight += 0.3;\n                newVelocity += length(mouseDist) * 2.0;\n            }\n            \n            // Ensure values stay in valid range\n            newMass = clamp(newMass, 0.0, 1.0);\n            newHeight = clamp(newHeight, 0.0, 1.0);\n            \n            gl_FragColor = vec4(newMass, newVelocity, newHeight, 1.0);\n        }',render:"precision highp float;\nvarying vec2 vUv;\nuniform sampler2D uState;\nuniform float uTime;\n\nuniform vec3 uBaseColor;\nuniform vec4 uSecondaryColor;\nuniform float uRoughness;\nuniform float uMetalness;\n\nvec3 calculateNormal(vec2 uv) {\n    vec2 texel = vec2(1.0) / vec2(textureSize(uState, 0));\n    float left = texture2D(uState, uv - vec2(texel.x, 0.0)).b;\n    float right = texture2D(uState, uv + vec2(texel.x, 0.0)).b;\n    float top = texture2D(uState, uv - vec2(0.0, texel.y)).b;\n    float bottom = texture2D(uState, uv + vec2(0.0, texel.y)).b;\n    \n    vec3 normal = normalize(vec3(\n        (right - left) * 2.0,\n        (bottom - top) * 2.0,\n        1.0\n    ));\n    \n    // Smooth normals based on height\n    float height = texture2D(uState, uv).b;\n    return mix(vec3(0.0, 0.0, 1.0), normal, smoothstep(0.1, 0.8, height));\n}\n\nfloat ggxDistribution(float NdotH, float roughness) {\n    float alpha = roughness * roughness;\n    float alpha2 = alpha * alpha;\n    float NdotH2 = NdotH * NdotH;\n    float denom = NdotH2 * (alpha2 - 1.0) + 1.0;\n    return alpha2 / (3.14159 * denom * denom);\n}\n\nfloat geometrySchlickGGX(float NdotV, float roughness) {\n    float r = roughness + 1.0;\n    float k = (r * r) / 8.0;\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvoid main() {\n    vec4 state = texture2D(uState, vUv);\n    float mass = state.r;\n    float height = state.b;\n    \n    vec3 normal = calculateNormal(vUv);\n    vec3 lightPos = vec3(2.0 * cos(uTime * 0.5), 2.0 * sin(uTime * 0.5), 2.0);\n    vec3 viewPos = vec3(0.0, 0.0, 2.0);\n    vec3 worldPos = vec3(vUv * 2.0 - 1.0, height);\n    \n    vec3 N = normal;\n    vec3 V = normalize(viewPos - worldPos);\n    vec3 L = normalize(lightPos - worldPos);\n    vec3 H = normalize(V + L);\n    \n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float NdotH = max(dot(N, H), 0.0);\n    float HdotV = max(dot(H, V), 0.0);\n    \n    vec3 F0 = mix(vec3(0.04), uBaseColor, uMetalness);\n    vec3 F = fresnelSchlick(HdotV, F0);\n    float D = ggxDistribution(NdotH, uRoughness);\n    float G = geometrySchlickGGX(NdotV, uRoughness) * geometrySchlickGGX(NdotL, uRoughness);\n    \n    // Apply height-based specular dampening while keeping original material properties\n    vec3 specular = (D * F * G) / (4.0 * NdotV * NdotL + 0.001);\n    specular *= smoothstep(0.0, 0.3, height);\n    \n    vec3 kD = (vec3(1.0) - F) * (1.0 - uMetalness);\n    vec3 diffuse = kD * uBaseColor / 3.14159;\n    \n    vec3 color = (diffuse + specular) * NdotL;\n    \n    // Original emission and ambient values\n    \n    if (uSecondaryColor.a > 0.0) {\n        color -= uBaseColor * mass * 0.399;\n        color += vec3(uSecondaryColor.rgb) * mass;\n    } else {\n        color = color + uBaseColor * mass * 0.399;\n    }\n    //color -= uBaseColor * mass * 0.399;\n    //color.b += mass * 0.29;\n    //color.g += mass * 0.009;\n    \n    // Original tone mapping and gamma correction\n    color = color / (color + vec3(1.0));\n    color = pow(color, vec3(1.0/2.5));\n    \n    gl_FragColor = vec4(color, 1.0);\n}",config:{baseColor:[.1,.01,.8],secondaryColor:[0,0,0,0],roughness:.2,metalness:0,neighborThreshold:.99,noiseFactor:0,speed:.15}},glass:{sim:' precision highp float;\n        varying vec2 vUv;\n        uniform sampler2D uPreviousState;\n        uniform vec2 uResolution;\n        uniform vec2 uMouse;\n        uniform bool uIsMouseDown;\n        uniform float uTime;\n        uniform float uNoiseFactor;\n        uniform float uNeighborThreshold;\n        uniform float uSpeed;\n\n        // Continuous neighborhood counting\n        vec4 getNeighborhood(vec2 uv) {\n            vec2 texel = 1.0 / uResolution;\n            float alive = 0.0;\n            float total = 0.0;\n            \n            // Sample in a radius around the current position\n            float radius = 3.0;\n            float count = 0.0;\n            \n            for(float y = -radius; y <= radius; y++) {\n                for(float x = -radius; x <= radius; x++) {\n                    vec2 offset = vec2(x, y) * texel;\n                    float dist = length(offset * uResolution / radius);\n                    \n                    // Only count cells within a circle\n                    if(dist <= radius) {\n                        // Gaussian weight based on distance\n                        float weight = exp(-dist * dist / 4.0);\n                        \n                        vec4 state = texture2D(uPreviousState, uv + offset);\n                        alive += state.r * weight;\n                        total += weight;\n                        count += 1.0;\n                    }\n                }\n            }\n            \n            // Normalize the count to 0-1 range\n            alive = alive / total;\n            \n            // Calculate how close we are to having "3 neighbors"\n            // Map the continuous value to peak at 3/8 (equivalent to 3 neighbors in discrete version)\n            float neighborFactor = 1.0 - abs(alive - 0.375) * 4.0;\n            \n            return vec4(alive, neighborFactor, count, total);\n        }\n\n        float hash(vec2 p) {\n            return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n        }\n\n        void main() {\n            vec4 prevState = texture2D(uPreviousState, vUv);\n            vec4 neighborhood = getNeighborhood(vUv);\n            \n            float currentMass = prevState.r;\n            float currentVelocity = prevState.g;\n            float currentHeight = prevState.b;\n            \n            // Continuous version of Conway\'s rules\n            float birthRate = 0.91;  // How quickly cells come alive\n            float deathRate = 0.91;  // How quickly cells die\n            float sustainRate = 0.9; // How well cells maintain their state\n            \n            // Calculate state change based on neighborhood\n            float neighborFactor = neighborhood.y;\n            float targetMass = 0.0;\n            \n            // Birth rule (continuous version of "exactly 3 neighbors")\n            if(neighborFactor > uNeighborThreshold) {\n                targetMass = 2.0;\n            }\n            // Death rule (continuous version of underpopulation/overpopulation)\n            else if(neighborFactor < 0.6) {\n                targetMass = 0.0;\n            }\n            // Sustain current state with slight decay\n            else {\n                targetMass = currentMass * sustainRate;\n            }\n            \n            // Add some noise and movement\n            float noise = hash(vUv + vec2(uTime * 0.01));\n            float noiseFactor = uNoiseFactor;\n            \n            // Calculate new state\n            float newMass = mix(currentMass, targetMass, uSpeed) + (noise - 0.5) * noiseFactor;\n            float newVelocity = currentVelocity * 0.95;\n            float newHeight = currentHeight * 0.98 + newMass * 0.1;\n            \n            // Mouse interaction\n            vec2 mouseDist = vUv - uMouse;\n            if( uIsMouseDown && length(mouseDist) < 0.03) {\n                newMass = 0.50;\n                newHeight += 0.3;\n                newVelocity += length(mouseDist) * 2.0;\n            }\n            \n            // Ensure values stay in valid range\n            newMass = clamp(newMass, 0.0, 1.0);\n            newHeight = clamp(newHeight, 0.0, 1.0);\n            \n            gl_FragColor = vec4(newMass, newVelocity, newHeight, 1.0);\n        }',render:"precision highp float;\nvarying vec2 vUv;\nuniform sampler2D uState;\nuniform float uTime;\n\nuniform vec3 uBaseColor;\nuniform vec4 uSecondaryColor;\nuniform float uRoughness;\nuniform float uMetalness;\nuniform sampler2D uImageTexture;\n\nvec3 calculateNormal(vec2 uv) {\n    vec2 texel = vec2(1.0) / vec2(textureSize(uState, 0));\n    float left = texture2D(uState, uv - vec2(texel.x, 0.0)).b;\n    float right = texture2D(uState, uv + vec2(texel.x, 0.0)).b;\n    float top = texture2D(uState, uv - vec2(0.0, texel.y)).b;\n    float bottom = texture2D(uState, uv + vec2(0.0, texel.y)).b;\n    \n    vec3 normal = normalize(vec3(\n        (right - left) * 2.0,\n        (bottom - top) * 2.0,\n        1.0\n    ));\n    \n    // Smooth normals based on height\n    float height = texture2D(uState, uv).b;\n    return mix(vec3(0.0, 0.0, 1.0), normal, smoothstep(0.1, 0.8, height));\n}\n\nfloat ggxDistribution(float NdotH, float roughness) {\n    float alpha = roughness * roughness;\n    float alpha2 = alpha * alpha;\n    float NdotH2 = NdotH * NdotH;\n    float denom = NdotH2 * (alpha2 - 1.0) + 1.0;\n    return alpha2 / (3.14159 * denom * denom);\n}\n\nfloat geometrySchlickGGX(float NdotV, float roughness) {\n    float r = roughness + 1.0;\n    float k = (r * r) / 8.0;\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvoid main() {\n    vec4 state = texture2D(uState, vUv);\n    float mass = state.r;\n    float height = state.b;\n    \n    vec3 normal = calculateNormal(vUv);\n    vec3 lightPos = vec3(2.0 * cos(uTime * 0.5), 2.0 * sin(uTime * 0.5), 2.0);\n    vec3 viewPos = vec3(0.0, 0.0, 2.0);\n    vec3 worldPos = vec3(vUv * 2.0 - 1.0, height);\n    \n    vec3 N = normal;\n    vec3 V = normalize(viewPos - worldPos);\n    vec3 L = normalize(lightPos - worldPos);\n    vec3 H = normalize(V + L);\n    \n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float NdotH = max(dot(N, H), 0.0);\n    float HdotV = max(dot(H, V), 0.0);\n    \n    vec3 F0 = mix(vec3(0.04), uBaseColor, uMetalness);\n    vec3 F = fresnelSchlick(HdotV, F0);\n    float D = ggxDistribution(NdotH, uRoughness);\n    float G = geometrySchlickGGX(NdotV, uRoughness) * geometrySchlickGGX(NdotL, uRoughness);\n    \n    // Apply height-based specular dampening while keeping original material properties\n    vec3 specular = (D * F * G) / (4.0 * NdotV * NdotL + 0.001);\n    specular *= smoothstep(0.0, 0.3, height);\n    \n    vec3 kD = (vec3(1.0) - F) * (1.0 - uMetalness);\n    vec3 diffuse = kD * uBaseColor / 3.14159;\n    \n    vec3 color = (diffuse + specular) * NdotL;\n    \n    // Original emission and ambient values\n    \n    if (uSecondaryColor.a > 0.0) {\n        color -= uBaseColor * mass * 0.399;\n        color += vec3(uSecondaryColor.rgb) * mass;\n    } else {\n        color = color + uBaseColor * mass * 0.399;\n    }\n    //color -= uBaseColor * mass * 0.399;\n    //color.b += mass * 0.29;\n    //color.g += mass * 0.009;\n    \n    // Sample the image texture with UV distortion based on height and mass\n    vec2 distortedUV = vUv + normal.xy * height * 0.1;\n    vec3 imageColor = texture2D(uImageTexture, distortedUV).rgb;\n    \n    // Create a more dynamic blend factor\n    float blendFactor = smoothstep(0.0, 0.8, mass * 0.7 + height * 0.5);\n    \n    // Blend colors with distortion\n    vec3 distortedColor = mix(\n        imageColor,\n        imageColor * (1.0 + height * 2.0) + specular,\n        blendFactor\n    );\n    \n    // Final color blend\n    color = mix(\n        distortedColor,\n        color + imageColor * mass,\n        blendFactor * 0.7\n    );\n    \n    // Add subtle chromatic aberration where the slime is active\n    if (blendFactor > 0.1) {\n        vec2 aberrationOffset = normal.xy * height * 0.02;\n        vec3 redChannel = texture2D(uImageTexture, distortedUV + aberrationOffset).rgb;\n        vec3 blueChannel = texture2D(uImageTexture, distortedUV - aberrationOffset).rgb;\n        color.r = mix(color.r, redChannel.r, blendFactor * 0.3);\n        color.b = mix(color.b, blueChannel.b, blendFactor * 0.3);\n    }\n    \n    // Original tone mapping and gamma correction\n    color = color / (color + vec3(1.0));\n    color = pow(color, vec3(1.0/2.2));\n    \n    gl_FragColor = vec4(color, 1.0);\n    // gl_FragColor = vec4(imageColor, 1.0);\n}",config:{baseColor:[.3,.3,.2],secondaryColor:[0,0,.5,1],roughness:.5,metalness:0,neighborThreshold:.99,noiseFactor:0,speed:.15}},dissolve:{sim:' precision highp float;\n        varying vec2 vUv;\n        uniform sampler2D uPreviousState;\n        uniform vec2 uResolution;\n        uniform vec2 uMouse;\n        uniform bool uIsMouseDown;\n        uniform float uTime;\n        uniform float uNoiseFactor;\n        uniform float uNeighborThreshold;\n        uniform float uSpeed;\n\n        // Continuous neighborhood counting\n        vec4 getNeighborhood(vec2 uv) {\n            vec2 texel = 1.0 / uResolution;\n            float alive = 0.0;\n            float total = 0.0;\n            \n            // Sample in a radius around the current position\n            float radius = 3.0;\n            float count = 0.0;\n            \n            for(float y = -radius; y <= radius; y++) {\n                for(float x = -radius; x <= radius; x++) {\n                    vec2 offset = vec2(x, y) * texel;\n                    float dist = length(offset * uResolution / radius);\n                    \n                    // Only count cells within a circle\n                    if(dist <= radius) {\n                        // Gaussian weight based on distance\n                        float weight = exp(-dist * dist / 4.0);\n                        \n                        vec4 state = texture2D(uPreviousState, uv + offset);\n                        alive += state.r * weight;\n                        total += weight;\n                        count += 1.0;\n                    }\n                }\n            }\n            \n            // Normalize the count to 0-1 range\n            alive = alive / total;\n            \n            // Calculate how close we are to having "3 neighbors"\n            // Map the continuous value to peak at 3/8 (equivalent to 3 neighbors in discrete version)\n            float neighborFactor = 1.0 - abs(alive - 0.375) * 4.0;\n            \n            return vec4(alive, neighborFactor, count, total);\n        }\n\n        float hash(vec2 p) {\n            return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n        }\n\n        void main() {\n            vec4 prevState = texture2D(uPreviousState, vUv);\n            vec4 neighborhood = getNeighborhood(vUv);\n            \n            float currentMass = prevState.r;\n            float currentVelocity = prevState.g;\n            float currentHeight = prevState.b;\n            \n            // Continuous version of Conway\'s rules\n            float birthRate = 0.91;  // How quickly cells come alive\n            float deathRate = 0.91;  // How quickly cells die\n            float sustainRate = 0.9; // How well cells maintain their state\n            \n            // Calculate state change based on neighborhood\n            float neighborFactor = neighborhood.y;\n            float targetMass = 0.0;\n            \n            // Birth rule (continuous version of "exactly 3 neighbors")\n            if(neighborFactor > uNeighborThreshold) {\n                targetMass = 2.0;\n            }\n            // Death rule (continuous version of underpopulation/overpopulation)\n            else if(neighborFactor < 0.6) {\n                targetMass = 0.0;\n            }\n            // Sustain current state with slight decay\n            else {\n                targetMass = currentMass * sustainRate;\n            }\n            \n            // Add some noise and movement\n            float noise = hash(vUv + vec2(uTime * 0.01));\n            float noiseFactor = uNoiseFactor;\n            \n            // Calculate new state\n            float newMass = mix(currentMass, targetMass, uSpeed) + (noise - 0.5) * noiseFactor;\n            float newVelocity = currentVelocity * 0.95;\n            float newHeight = currentHeight * 0.98 + newMass * 0.1;\n            \n            // Mouse interaction\n            vec2 mouseDist = vUv - uMouse;\n            if( uIsMouseDown && length(mouseDist) < 0.03) {\n                newMass = 0.50;\n                newHeight += 0.3;\n                newVelocity += length(mouseDist) * 2.0;\n            }\n            \n            // Ensure values stay in valid range\n            newMass = clamp(newMass, 0.0, 1.0);\n            newHeight = clamp(newHeight, 0.0, 1.0);\n            \n            gl_FragColor = vec4(newMass, newVelocity, newHeight, 1.0);\n        }',render:'precision highp float;\nvarying vec2 vUv;\nuniform sampler2D uState;\nuniform float uTime;\n\nuniform vec3 uBaseColor;\nuniform vec4 uSecondaryColor;\nuniform float uRoughness;\nuniform float uMetalness;\nuniform sampler2D uImageTexture;\n\nvec3 calculateNormal(vec2 uv) {\n    vec2 texel = vec2(1.0) / vec2(textureSize(uState, 0));\n    float left = texture2D(uState, uv - vec2(texel.x, 0.0)).b;\n    float right = texture2D(uState, uv + vec2(texel.x, 0.0)).b;\n    float top = texture2D(uState, uv - vec2(0.0, texel.y)).b;\n    float bottom = texture2D(uState, uv + vec2(0.0, texel.y)).b;\n    \n    vec3 normal = normalize(vec3(\n        (right - left) * 2.0,\n        (bottom - top) * 2.0,\n        1.0\n    ));\n    \n    // Smooth normals based on height\n    float height = texture2D(uState, uv).b;\n    return mix(vec3(0.0, 0.0, 1.0), normal, smoothstep(0.1, 0.8, height));\n}\n\nfloat ggxDistribution(float NdotH, float roughness) {\n    float alpha = roughness * roughness;\n    float alpha2 = alpha * alpha;\n    float NdotH2 = NdotH * NdotH;\n    float denom = NdotH2 * (alpha2 - 1.0) + 1.0;\n    return alpha2 / (3.14159 * denom * denom);\n}\n\nfloat geometrySchlickGGX(float NdotV, float roughness) {\n    float r = roughness + 1.0;\n    float k = (r * r) / 8.0;\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvoid main() {\n    vec4 state = texture2D(uState, vUv);\n    float mass = state.r;\n    float height = state.b;\n    \n    vec3 normal = calculateNormal(vUv);\n    vec3 lightPos = vec3(2.0 * cos(uTime * 0.5), 2.0 * sin(uTime * 0.5), 2.0);\n    vec3 viewPos = vec3(0.0, 0.0, 2.0);\n    vec3 worldPos = vec3(vUv * 2.0 - 1.0, height);\n    \n    vec3 N = normal;\n    vec3 V = normalize(viewPos - worldPos);\n    vec3 L = normalize(lightPos - worldPos);\n    vec3 H = normalize(V + L);\n    \n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float NdotH = max(dot(N, H), 0.0);\n    float HdotV = max(dot(H, V), 0.0);\n    \n    vec3 F0 = mix(vec3(0.04), uBaseColor, uMetalness);\n    vec3 F = fresnelSchlick(HdotV, F0);\n    float D = ggxDistribution(NdotH, uRoughness);\n    float G = geometrySchlickGGX(NdotV, uRoughness) * geometrySchlickGGX(NdotL, uRoughness);\n    \n    // Apply height-based specular dampening while keeping original material properties\n    vec3 specular = (D * F * G) / (4.0 * NdotV * NdotL + 0.001);\n    specular *= smoothstep(0.0, 0.3, height);\n    \n    vec3 kD = (vec3(1.0) - F) * (1.0 - uMetalness);\n    vec3 diffuse = kD * uBaseColor / 3.14159;\n    \n    vec3 color = (diffuse + specular) * NdotL;\n    \n    // Original emission and ambient values\n    \n    if (uSecondaryColor.a > 0.0) {\n        color -= uBaseColor * mass * 0.399;\n        color += vec3(uSecondaryColor.rgb) * mass;\n    } else {\n        color = color + uBaseColor * mass * 0.399;\n    }\n    //color -= uBaseColor * mass * 0.399;\n    //color.b += mass * 0.29;\n    //color.g += mass * 0.009;\n    \n    // Sample the image texture\n    vec3 imageColor = texture2D(uImageTexture, vUv).rgb;\n    \n    // Create an "eaten away" effect with wetness\n    float dissolveAmount = mass * 0.9 + height * 0.3;\n    \n    // Create wet edge effect\n    float wetFactor = smoothstep(0.1, 0.4, dissolveAmount);\n    vec3 wetColor = mix(imageColor, uBaseColor, 0.3) * (1.0 + specular * 2.0);\n    \n    // Add fresnel-like edge highlighting\n    float fresnel = pow(1.0 - NdotV, 3.0);\n    vec3 edgeHighlight = mix(vec3(0.0), uBaseColor * 2.0, fresnel * wetFactor);\n    \n    // Blend between image, wet effect, and fully dissolved state\n    float dissolveMix = smoothstep(0.2, 0.4, dissolveAmount);\n    vec3 baseEffect = mix(imageColor, wetColor, wetFactor);\n    \n    // Final color composition\n    color = mix(baseEffect, color + edgeHighlight, dissolveMix);\n    color += specular * wetFactor * 2.0; // Enhanced specular for wet areas\n    \n    // Add subtle chromatic aberration at edges\n    float edgeGlow = smoothstep(0.1, 0.2, dissolveAmount) - smoothstep(0.3, 0.4, dissolveAmount);\n    vec2 aberrationOffset = normal.xy * edgeGlow * 0.02;\n    // color.r += texture2D(uImageTexture, vUv + aberrationOffset).r * edgeGlow * 0.05;\n    color.b += texture2D(uImageTexture, vUv - aberrationOffset).b * edgeGlow * 0.5;\n    \n    // Original tone mapping and gamma correction\n    color = color / (color + vec3(1.0));\n    color = pow(color, vec3(1.0/2.2));\n    \n    gl_FragColor = vec4(color, 1.0);\n    // gl_FragColor = vec4(imageColor, 1.0);\n}',config:{baseColor:[0,0,0],secondaryColor:[1,1,1,.5],roughness:.2,metalness:0,neighborThreshold:.99,noiseFactor:0,speed:.15}},image:{sim:' precision highp float;\n        varying vec2 vUv;\n        uniform sampler2D uPreviousState;\n        uniform vec2 uResolution;\n        uniform vec2 uMouse;\n        uniform bool uIsMouseDown;\n        uniform float uTime;\n        uniform float uNoiseFactor;\n        uniform float uNeighborThreshold;\n        uniform float uSpeed;\n\n        // Continuous neighborhood counting\n        vec4 getNeighborhood(vec2 uv) {\n            vec2 texel = 1.0 / uResolution;\n            float alive = 0.0;\n            float total = 0.0;\n            \n            // Sample in a radius around the current position\n            float radius = 3.0;\n            float count = 0.0;\n            \n            for(float y = -radius; y <= radius; y++) {\n                for(float x = -radius; x <= radius; x++) {\n                    vec2 offset = vec2(x, y) * texel;\n                    float dist = length(offset * uResolution / radius);\n                    \n                    // Only count cells within a circle\n                    if(dist <= radius) {\n                        // Gaussian weight based on distance\n                        float weight = exp(-dist * dist / 4.0);\n                        \n                        vec4 state = texture2D(uPreviousState, uv + offset);\n                        alive += state.r * weight;\n                        total += weight;\n                        count += 1.0;\n                    }\n                }\n            }\n            \n            // Normalize the count to 0-1 range\n            alive = alive / total;\n            \n            // Calculate how close we are to having "3 neighbors"\n            // Map the continuous value to peak at 3/8 (equivalent to 3 neighbors in discrete version)\n            float neighborFactor = 1.0 - abs(alive - 0.375) * 4.0;\n            \n            return vec4(alive, neighborFactor, count, total);\n        }\n\n        float hash(vec2 p) {\n            return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n        }\n\n        void main() {\n            vec4 prevState = texture2D(uPreviousState, vUv);\n            vec4 neighborhood = getNeighborhood(vUv);\n            \n            float currentMass = prevState.r;\n            float currentVelocity = prevState.g;\n            float currentHeight = prevState.b;\n            \n            // Continuous version of Conway\'s rules\n            float birthRate = 0.91;  // How quickly cells come alive\n            float deathRate = 0.91;  // How quickly cells die\n            float sustainRate = 0.9; // How well cells maintain their state\n            \n            // Calculate state change based on neighborhood\n            float neighborFactor = neighborhood.y;\n            float targetMass = 0.0;\n            \n            // Birth rule (continuous version of "exactly 3 neighbors")\n            if(neighborFactor > uNeighborThreshold) {\n                targetMass = 2.0;\n            }\n            // Death rule (continuous version of underpopulation/overpopulation)\n            else if(neighborFactor < 0.6) {\n                targetMass = 0.0;\n            }\n            // Sustain current state with slight decay\n            else {\n                targetMass = currentMass * sustainRate;\n            }\n            \n            // Add some noise and movement\n            float noise = hash(vUv + vec2(uTime * 0.01));\n            float noiseFactor = uNoiseFactor;\n            \n            // Calculate new state\n            float newMass = mix(currentMass, targetMass, uSpeed) + (noise - 0.5) * noiseFactor;\n            float newVelocity = currentVelocity * 0.95;\n            float newHeight = currentHeight * 0.98 + newMass * 0.1;\n            \n            // Mouse interaction\n            vec2 mouseDist = vUv - uMouse;\n            if( uIsMouseDown && length(mouseDist) < 0.03) {\n                newMass = 0.50;\n                newHeight += 0.3;\n                newVelocity += length(mouseDist) * 2.0;\n            }\n            \n            // Ensure values stay in valid range\n            newMass = clamp(newMass, 0.0, 1.0);\n            newHeight = clamp(newHeight, 0.0, 1.0);\n            \n            gl_FragColor = vec4(newMass, newVelocity, newHeight, 1.0);\n        }',render:"precision highp float;\nvarying vec2 vUv;\nuniform sampler2D uState;\nuniform float uTime;\n\nuniform vec3 uBaseColor;\nuniform vec4 uSecondaryColor;\nuniform float uRoughness;\nuniform float uMetalness;\nuniform sampler2D uImageTexture;\n\nvec3 calculateNormal(vec2 uv) {\n    vec2 texel = vec2(1.0) / vec2(textureSize(uState, 0));\n    float left = texture2D(uState, uv - vec2(texel.x, 0.0)).b;\n    float right = texture2D(uState, uv + vec2(texel.x, 0.0)).b;\n    float top = texture2D(uState, uv - vec2(0.0, texel.y)).b;\n    float bottom = texture2D(uState, uv + vec2(0.0, texel.y)).b;\n    \n    vec3 normal = normalize(vec3(\n        (right - left) * 2.0,\n        (bottom - top) * 2.0,\n        1.0\n    ));\n    \n    // Smooth normals based on height\n    float height = texture2D(uState, uv).b;\n    return mix(vec3(0.0, 0.0, 1.0), normal, smoothstep(0.1, 0.8, height));\n}\n\nfloat ggxDistribution(float NdotH, float roughness) {\n    float alpha = roughness * roughness;\n    float alpha2 = alpha * alpha;\n    float NdotH2 = NdotH * NdotH;\n    float denom = NdotH2 * (alpha2 - 1.0) + 1.0;\n    return alpha2 / (3.14159 * denom * denom);\n}\n\nfloat geometrySchlickGGX(float NdotV, float roughness) {\n    float r = roughness + 1.0;\n    float k = (r * r) / 8.0;\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvoid main() {\n    vec4 state = texture2D(uState, vUv);\n    float mass = state.r;\n    float height = state.b;\n    \n    vec3 normal = calculateNormal(vUv);\n    vec3 lightPos = vec3(2.0 * cos(uTime * 0.5), 2.0 * sin(uTime * 0.5), 2.0);\n    vec3 viewPos = vec3(0.0, 0.0, 2.0);\n    vec3 worldPos = vec3(vUv * 2.0 - 1.0, height);\n    \n    vec3 N = normal;\n    vec3 V = normalize(viewPos - worldPos);\n    vec3 L = normalize(lightPos - worldPos);\n    vec3 H = normalize(V + L);\n    \n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float NdotH = max(dot(N, H), 0.0);\n    float HdotV = max(dot(H, V), 0.0);\n    \n    vec3 F0 = mix(vec3(0.04), uBaseColor, uMetalness);\n    vec3 F = fresnelSchlick(HdotV, F0);\n    float D = ggxDistribution(NdotH, uRoughness);\n    float G = geometrySchlickGGX(NdotV, uRoughness) * geometrySchlickGGX(NdotL, uRoughness);\n    \n    // Apply height-based specular dampening while keeping original material properties\n    vec3 specular = (D * F * G) / (4.0 * NdotV * NdotL + 0.001);\n    specular *= smoothstep(0.0, 0.3, height);\n    \n    vec3 kD = (vec3(1.0) - F) * (1.0 - uMetalness);\n    vec3 diffuse = kD * uBaseColor / 3.14159;\n    \n    vec3 color = (diffuse + specular) * NdotL;\n    \n    // Original emission and ambient values\n    \n    if (uSecondaryColor.a > 0.0) {\n        color -= uBaseColor * mass * 0.399;\n        color += vec3(uSecondaryColor.rgb) * mass;\n    } else {\n        color = color + uBaseColor * mass * 0.399;\n    }\n    //color -= uBaseColor * mass * 0.399;\n    //color.b += mass * 0.29;\n    //color.g += mass * 0.009;\n    \n    // Sample the image texture\n    vec3 imageColor = texture2D(uImageTexture, vUv).rgb;\n    \n    // Blend based on mass and height\n    float blendFactor = mass * 0.7 + height * 0.3;\n    color = mix(imageColor, color, blendFactor);\n    \n    // Original tone mapping and gamma correction\n    color = color / (color + vec3(1.0));\n    color = pow(color, vec3(1.0/2.2));\n    \n    gl_FragColor = vec4(color, 1.0);\n    // gl_FragColor = vec4(imageColor, 1.0);\n}",config:{baseColor:[.1,.01,.8],secondaryColor:[0,0,0,0],roughness:.2,metalness:0,neighborThreshold:.99,noiseFactor:0,speed:.15}},modern:{sim:' precision highp float;\n        varying vec2 vUv;\n        uniform sampler2D uPreviousState;\n        uniform vec2 uResolution;\n        uniform vec2 uMouse;\n        uniform bool uIsMouseDown;\n        uniform float uTime;\n        uniform float uSpeed;\n        uniform float uNoiseFactor;\n        uniform float uNeighborThreshold;\n        // Continuous neighborhood counting\n        vec4 getNeighborhood(vec2 uv) {\n            vec2 texel = 1.0 / uResolution;\n            float alive = 0.0;\n            float total = 0.0;\n            \n            // Sample in a radius around the current position\n            float radius = 3.0;\n            float count = 0.0;\n            \n            for(float y = -radius; y <= radius; y++) {\n                for(float x = -radius; x <= radius; x++) {\n                    vec2 offset = vec2(x, y) * texel;\n                    float dist = length(offset * uResolution / radius);\n                    \n                    // Only count cells within a circle\n                    if(dist <= radius) {\n                        // Gaussian weight based on distance\n                        float weight = exp(-dist * dist / 4.0);\n                        \n                        vec4 state = texture2D(uPreviousState, uv + offset);\n                        alive += state.r * weight;\n                        total += weight;\n                        count += 1.0;\n                    }\n                }\n            }\n            \n            // Normalize the count to 0-1 range\n            alive = alive / total;\n            \n            // Calculate how close we are to having "3 neighbors"\n            // Map the continuous value to peak at 3/8 (equivalent to 3 neighbors in discrete version)\n            float neighborFactor = 1.0 - abs(alive - 0.375) * 4.0;\n            \n            return vec4(alive, neighborFactor, count, total);\n        }\n\n        float hash(vec2 p) {\n            return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n        }\n\n        void main() {\n            vec4 prevState = texture2D(uPreviousState, vUv);\n            vec4 neighborhood = getNeighborhood(vUv);\n            \n            float currentMass = prevState.r;\n            float currentVelocity = prevState.g;\n            float currentHeight = prevState.b;\n            \n            // Continuous version of Conway\'s rules\n            float birthRate = 0.91;  // How quickly cells come alive\n            float deathRate = 0.9;  // How quickly cells die\n            float sustainRate = 0.98; // How well cells maintain their state\n            \n            // Calculate state change based on neighborhood\n            float neighborFactor = neighborhood.y;\n            float targetMass = 0.0;\n            \n            // Birth rule (continuous version of "exactly 3 neighbors")\n            if(neighborFactor > 0.9) {\n                targetMass = 100.0;\n            }\n            // Death rule (continuous version of underpopulation/overpopulation)\n            else if(neighborFactor < 0.89) {\n                targetMass = 0.0;\n            }\n            // Sustain current state with slight decay\n            else {\n                targetMass = currentMass * sustainRate;\n            }\n            \n            // Add some noise and movement\n            float noise = hash(vUv + vec2(uTime * 0.01));\n            float noiseFactor = 0.;\n            \n            // Calculate new stat\n            float newMass = mix(currentMass, targetMass, 0.2) + (noise - 0.5) * noiseFactor;\n            float newVelocity = currentVelocity * 0.95;\n            float newHeight = currentHeight * 0.98 + newMass * 0.1;\n            \n            // Mouse interaction\n            vec2 mouseDist = vUv - uMouse;\n            if( uIsMouseDown && length(mouseDist) < 0.04) {\n                newMass = 0.45;\n                newHeight += 0.3;\n                newVelocity += length(mouseDist) * 2.0;\n            }\n            \n            // Ensure values stay in valid range\n            newMass = clamp(newMass, 0.0, 1.0);\n            newHeight = clamp(newHeight, 0.0, 1.0);\n            \n            gl_FragColor = vec4(newMass, newVelocity, newHeight, 1.0);\n        }',render:"precision highp float;\n        varying vec2 vUv;\n        uniform sampler2D uState;\n        uniform float uTime;\n\n        uniform vec3 uBaseColor;\n        uniform vec4 uSecondaryColor;\n        uniform float uRoughness;\n        uniform float uMetalness;\n        uniform sampler2D uImageTexture;\n\n        // Normal calculation from height field\n        vec3 calculateNormal(vec2 uv) {\n            vec2 texel = vec2(1.0) / vec2(textureSize(uState, 0));\n            float left = texture2D(uState, uv - vec2(texel.x, 0.0)).b;\n            float right = texture2D(uState, uv + vec2(texel.x, 0.0)).b;\n            float top = texture2D(uState, uv - vec2(0.0, texel.y)).b;\n            float bottom = texture2D(uState, uv + vec2(0.0, texel.y)).b;\n            \n            return normalize(vec3(\n                (right - left) * 2.0,\n                (bottom - top) * 2.0,\n                1.0\n            ));\n        }\n\n        // PBR functions\n        float ggxDistribution(float NdotH, float roughness) {\n            float alpha = roughness * roughness;\n            float alpha2 = alpha * alpha;\n            float NdotH2 = NdotH * NdotH;\n            float denom = NdotH2 * (alpha2 - 1.0) + 1.0;\n            return alpha2 / (3.14159 * denom * denom);\n        }\n\n        float geometrySchlickGGX(float NdotV, float roughness) {\n            float r = roughness + 1.0;\n            float k = (r * r) / 8.0;\n            return NdotV / (NdotV * (1.0 - k) + k);\n        }\n\n        vec3 fresnelSchlick(float cosTheta, vec3 F0) {\n            return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n        }\n\n        void main() {\n            vec4 state = texture2D(uState, vUv);\n            float mass = state.r;\n            float height = state.b;\n            \n            // Calculate lighting vectors\n            vec3 normal = calculateNormal(vUv);\n            vec3 lightPos = vec3(2.0 * cos(uTime * 0.5), 2.0 * sin(uTime * 0.5), 2.0);\n            vec3 viewPos = vec3(0.0, 0.0, 2.0);\n            vec3 worldPos = vec3(vUv * 2.0 - 1.0, height);\n            \n            vec3 N = normal;\n            vec3 V = normalize(viewPos - worldPos);\n            vec3 L = normalize(lightPos - worldPos);\n            vec3 H = normalize(V + L);\n            \n            float NdotV = max(dot(N, V), 0.0);\n            float NdotL = max(dot(N, L), 0.0);\n            float NdotH = max(dot(N, H), 0.0);\n            float HdotV = max(dot(H, V), 0.0);\n            \n            // Use uniforms instead of constants\n            vec3 F0 = mix(vec3(0.04), uBaseColor, uMetalness);\n            vec3 F = fresnelSchlick(HdotV, F0);\n            float D = ggxDistribution(NdotH, uRoughness);\n            float G = geometrySchlickGGX(NdotV, uRoughness) * geometrySchlickGGX(NdotL, uRoughness);\n            \n            // Combine lighting with uniforms\n            vec3 specular = (D * F * G) / (4.0 * NdotV * NdotL + 0.001);\n            vec3 kD = (vec3(1.0) - F) * (1.0 - uMetalness);\n            vec3 diffuse = kD * uBaseColor / 3.14159;\n            \n            vec3 color = (diffuse + specular) * NdotL;\n            \n            // Use secondary color for emission effects\n            color -= uBaseColor * mass * uSecondaryColor.a;\n            color += uSecondaryColor.rgb * mass * 0.22;\n            \n            // Add ambient with base color\n            color += uBaseColor * 0.89;\n            \n            // Tone mapping and gamma correction\n            color = color / (color + vec3(1.0));\n            color = pow(color, vec3(1.0/2.5));\n            \n            gl_FragColor = vec4(color, 1.0);\n        }",config:{baseColor:[1,1,1],secondaryColor:[0,0,1,.29],roughness:.2,metalness:1,neighborThreshold:.99,noiseFactor:0,speed:.15}},tar:{sim:" precision highp float;\n        varying vec2 vUv;\n        uniform sampler2D uPreviousState;\n        uniform vec2 uResolution;\n        uniform vec2 uMouse;\n        uniform bool uIsMouseDown;\n        uniform float uTime;\n        uniform float uNoiseFactor;\n        uniform float uNeighborThreshold;\n        uniform float uSpeed;\n\n        vec4 getNeighborhood(vec2 uv) {\n            vec2 texel = 1.0 / uResolution;\n            float alive = 0.0;\n            float total = 0.0;\n            \n            // Increased radius for more spread\n            float radius = 6.0;\n            float count = 0.0;\n            \n            for(float y = -radius; y <= radius; y++) {\n                for(float x = -radius; x <= radius; x++) {\n                    vec2 offset = vec2(x, y) * texel;\n                    float dist = length(offset * uResolution / radius);\n                    \n                    if(dist <= radius) {\n                        // Adjusted weight calculation for zoomed effect\n                        float weight = exp(-dist * dist / 8.0);\n                        \n                        vec4 state = texture2D(uPreviousState, uv + offset);\n                        alive += state.r * weight;\n                        total += weight;\n                        count += 1.0;\n                    }\n                }\n            }\n            \n            alive = alive / total;\n            float neighborFactor = 1.0 - abs(alive - 0.375) * 4.0;\n            \n            return vec4(alive, neighborFactor, count, total);\n        }\n\n        float hash(vec2 p) {\n            return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n        }\n\n        void main() {\n            // Scale UV coordinates to create zoom effect\n            vec2 zoomedUV = (vUv - 0.5) * 2.0 + 0.5;\n            vec4 prevState = texture2D(uPreviousState, vUv);\n            vec4 neighborhood = getNeighborhood(vUv);\n            \n            float currentMass = prevState.r;\n            float currentVelocity = prevState.g;\n            float currentHeight = prevState.b;\n            \n            // Adjusted parameters for zoomed view\n            float birthRate = 0.99;\n            float deathRate = 0.1;\n            float sustainRate = 0.985;\n            \n            float neighborFactor = neighborhood.y;\n            float targetMass = 0.0;\n            \n            if(neighborFactor > uNeighborThreshold) {\n                targetMass = 10.0;\n            }\n            else if(neighborFactor < 0.89) {\n                targetMass = 0.0;\n            }\n            else {\n                targetMass = currentMass * sustainRate;\n            }\n            \n            float noise = hash(vUv + vec2(uTime * 0.01));\n            float noiseFactor = uNoiseFactor;\n            \n            float newMass = mix(currentMass, targetMass, uSpeed) + (noise - 0.5) * noiseFactor;\n            float newVelocity = currentVelocity * 0.97;\n            float newHeight = currentHeight * 0.99 + newMass * 0.15;\n            \n            // Adjusted mouse interaction for zoomed view\n            vec2 mouseDist = vUv - uMouse;\n            if(uIsMouseDown && length(mouseDist) < 0.05) {\n                newMass = 0.6;\n                newHeight += 0.4;\n                newVelocity += length(mouseDist) * 3.0;\n            }\n            \n            newMass = clamp(newMass, 0.0, 1.0);\n            newHeight = clamp(newHeight, 0.0, 1.0);\n            \n            gl_FragColor = vec4(newMass, newVelocity, newHeight, 1.0);\n        }",render:"  precision highp float;\n        varying vec2 vUv;\n        uniform sampler2D uState;\n        uniform float uTime;\n\n        uniform vec3 uBaseColor;\n        uniform vec4 uSecondaryColor;\n        uniform float uRoughness;\n        uniform float uMetalness;\n\n        vec3 calculateNormal(vec2 uv) {\n            vec2 texel = vec2(1.0) / vec2(textureSize(uState, 0));\n            float left = texture2D(uState, uv - vec2(texel.x, 0.0)).b;\n            float right = texture2D(uState, uv + vec2(texel.x, 0.0)).b;\n            float top = texture2D(uState, uv - vec2(0.0, texel.y)).b;\n            float bottom = texture2D(uState, uv + vec2(0.0, texel.y)).b;\n            \n            return normalize(vec3(\n                (right - left) * 4.0, // Increased normal strength\n                (bottom - top) * 4.0,\n                0.8 // Adjusted Z component for more pronounced effect\n            ));\n        }\n\n        float ggxDistribution(float NdotH, float roughness) {\n            float alpha = roughness * roughness;\n            float alpha2 = alpha * alpha;\n            float NdotH2 = NdotH * NdotH;\n            float denom = NdotH2 * (alpha2 - 1.0) + 1.0;\n            return alpha2 / (3.14159 * denom * denom);\n        }\n\n        float geometrySchlickGGX(float NdotV, float roughness) {\n            float r = roughness + 1.0;\n            float k = (r * r) / 8.0;\n            return NdotV / (NdotV * (1.0 - k) + k);\n        }\n\n        vec3 fresnelSchlick(float cosTheta, vec3 F0) {\n            return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n        }\n\n        void main() {\n            vec4 state = texture2D(uState, vUv);\n            float mass = state.r;\n            float height = state.b;\n            \n            vec3 normal = calculateNormal(vUv);\n            vec3 lightPos = vec3(2.0 * cos(uTime * 0.5), 2.0 * sin(uTime * 0.5), 1.5);\n            vec3 viewPos = vec3(0.0, 0.0, 1.5);\n            vec3 worldPos = vec3(vUv * 2.0 - 1.0, height * 1.5); // Increased height effect\n            \n            vec3 N = normal;\n            vec3 V = normalize(viewPos - worldPos);\n            vec3 L = normalize(lightPos - worldPos);\n            vec3 H = normalize(V + L);\n            \n            float NdotV = max(dot(N, V), 0.0);\n            float NdotL = max(dot(N, L), 0.0);\n            float NdotH = max(dot(N, H), 0.0);\n            float HdotV = max(dot(H, V), 0.0);\n            \n            vec3 F0 = mix(vec3(0.04), uBaseColor, uMetalness);\n            vec3 F = fresnelSchlick(HdotV, F0);\n            float D = ggxDistribution(NdotH, uRoughness);\n            float G = geometrySchlickGGX(NdotV, uRoughness) * geometrySchlickGGX(NdotL, uRoughness);\n            \n            vec3 specular = (D * F * G) / (4.0 * NdotV * NdotL + 0.001);\n            vec3 kD = (vec3(1.0) - F) * (1.0 - uMetalness);\n            vec3 diffuse = kD * uBaseColor / 3.14159;\n            \n            vec3 color = (diffuse + specular) * NdotL;\n            \n            // Enhanced emission effect\n            color -= uBaseColor * mass * 0.25;\n            color.b += mass * 0.02;\n            color.g += mass * 0.012;\n            \n            color += uBaseColor * 0.85;\n            \n            color = color / (color + vec3(1.0));\n            color = pow(color, vec3(1.0/2.2));\n            \n            gl_FragColor = vec4(color, 1.0);\n        }",config:{baseColor:[0,0,0],secondaryColor:[0,0,0,0],roughness:.15,metalness:.9,neighborThreshold:.9,noiseFactor:.005,speed:.1}}};async function a(e,n){return"vert"===e?(console.log("vertex shader loading"),o.vert):o[e][n]}exports.SlimeSimulation=class{constructor(e={}){this.shaders=["dissolve","glass","original","image"],this.currentShader=e.slimeType||"original",this.imageUrl=e.imageUrl||null,this.init()}async init(){if(await this.loadCurrentShaderConfig(),this.imageUrl)await this.initImageTexture(this.imageUrl);else{const e=new n.DataTexture(new Uint8Array([255,255,255,255]),1,1,n.RGBAFormat);e.needsUpdate=!0,this.imageTexture=e}await this.initRenderer(),await this.initShaders(),this.initScene(),this.initSimulation(),this.initTransitionState(),this.addEventListeners(),this.animate(),this.mouseTimeout=null}loadCurrentShaderConfig=async()=>{this.currentConfig=await async function(e){return o[e].config}(this.currentShader)};initShaders=async()=>{this.vertexShader=await a("vert",null),this.simulationShader=await a(this.currentShader,"sim"),this.renderShader=await a(this.currentShader,"render")};initTransitionState(){this.transitionManager=new t(this.simulationMaterial,this.renderMaterial)}startTransition(e){this.transitionManager.startTransition(e)}initRenderer=async()=>{this.renderer=new n.WebGLRenderer({canvas:document.getElementById("canvas"),antialias:!0}),this.renderer.setSize(window.innerWidth,window.innerHeight),this.renderer.setPixelRatio(window.devicePixelRatio)};initScene(){this.scene=new n.Scene,this.camera=new n.OrthographicCamera(-1,1,1,-1,0,1),this.quad=new n.PlaneGeometry(2,2)}initSimulation(){const e=512;this.size=e,this.renderTargets=[new n.WebGLRenderTarget(e,e,{minFilter:n.LinearFilter,magFilter:n.LinearFilter,format:n.RGBAFormat,type:n.FloatType}),new n.WebGLRenderTarget(e,e,{minFilter:n.LinearFilter,magFilter:n.LinearFilter,format:n.RGBAFormat,type:n.FloatType})],this.simulationMaterial=new n.ShaderMaterial({vertexShader:this.vertexShader,fragmentShader:this.simulationShader,uniforms:{uPreviousState:{value:null},uResolution:{value:new n.Vector2(e,e)},uMouse:{value:new n.Vector2(.5,.5)},uIsMouseDown:{value:!1},uTime:{value:0},uNoiseFactor:{value:this.currentConfig.noiseFactor},uNeighborThreshold:{value:this.currentConfig.neighborThreshold},uSpeed:{value:this.currentConfig.speed}}}),this.renderMaterial=new n.ShaderMaterial({vertexShader:this.vertexShader,fragmentShader:this.renderShader,uniforms:{uState:{value:null},uTime:{value:0},uBaseColor:{value:new n.Vector3(...this.currentConfig.baseColor.slice(0,3))},uSecondaryColor:{value:new n.Vector4(...this.currentConfig.secondaryColor)},uRoughness:{value:this.currentConfig.roughness},uMetalness:{value:this.currentConfig.metalness},uImageTexture:{value:this.imageTexture}}});const t=new Float32Array(1048576);for(let e=0;e<t.length;e+=4)t[e]=.1*Math.random(),t[e+1]=0,t[e+2]=0,t[e+3]=1;this.renderer.setRenderTarget(this.renderTargets[0]);const o=new n.DataTexture(t,e,e,n.RGBAFormat,n.FloatType);o.needsUpdate=!0;const a=new n.Mesh(this.quad,new n.MeshBasicMaterial({map:o})),r=new n.Scene;r.add(a),this.renderer.render(r,this.camera),this.renderer.setRenderTarget(null)}initImageTexture=async e=>{try{this.imageTexture=await async function(e){return new Promise((t=>{(new n.TextureLoader).load(e,t)}))}(e)}catch(e){console.warn("Failed to load image texture:",e);const t=new n.DataTexture(new Uint8Array([255,255,255,255]),1,1,n.RGBAFormat);t.needsUpdate=!0,this.imageTexture=t}};addEventListeners(){window.addEventListener("resize",this.onResize.bind(this)),window.addEventListener("mousemove",this.onMouseMove.bind(this))}onResize(){this.renderer.setSize(window.innerWidth,window.innerHeight)}onMouseMove(e){this.simulationMaterial.uniforms.uMouse.value.x=e.clientX/window.innerWidth,this.simulationMaterial.uniforms.uMouse.value.y=1-e.clientY/window.innerHeight,this.simulationMaterial.uniforms.uIsMouseDown.value=!0,this.mouseTimeout&&clearTimeout(this.mouseTimeout),this.mouseTimeout=setTimeout((()=>{this.simulationMaterial.uniforms.uIsMouseDown.value=!1}),20)}animate(){requestAnimationFrame(this.animate.bind(this));const e=.001*performance.now();this.simulationMaterial.uniforms.uTime.value=e,this.renderMaterial.uniforms.uTime.value=e,this.transitionManager.update(),this.simulationMaterial.uniforms.uPreviousState.value=this.renderTargets[0].texture,this.renderer.setRenderTarget(this.renderTargets[1]),this.renderer.render((new n.Scene).add(new n.Mesh(this.quad,this.simulationMaterial)),this.camera),this.renderMaterial.uniforms.uState.value=this.renderTargets[1].texture,this.renderer.setRenderTarget(null),this.renderer.render((new n.Scene).add(new n.Mesh(this.quad,this.renderMaterial)),this.camera),[this.renderTargets[0],this.renderTargets[1]]=[this.renderTargets[1],this.renderTargets[0]]}changeShader=async e=>{this.shaders.includes(e)?(this.currentShader=e,await this.loadCurrentShaderConfig(),await this.initShaders(),this.simulationMaterial.uniforms.uNoiseFactor.value=this.currentConfig.noiseFactor,this.simulationMaterial.uniforms.uNeighborThreshold.value=this.currentConfig.neighborThreshold,this.simulationMaterial.uniforms.uSpeed.value=this.currentConfig.speed,this.renderMaterial.uniforms.uBaseColor.value.set(...this.currentConfig.baseColor.slice(0,3)),this.renderMaterial.uniforms.uSecondaryColor.value.set(...this.currentConfig.secondaryColor),this.renderMaterial.uniforms.uRoughness.value=this.currentConfig.roughness,this.renderMaterial.uniforms.uMetalness.value=this.currentConfig.metalness):console.error(`Invalid shader name: ${e}`)};async updateImage(e){if(!e)throw new Error("Image URL is required");await this.initImageTexture(e),this.renderMaterial.uniforms.uImageTexture.value=this.imageTexture}};
//# sourceMappingURL=slime-simulation.js.map
